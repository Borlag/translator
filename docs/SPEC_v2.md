# Автоперевод CMM/AMM DOCX → RU: ТЗ, архитектура и промпты для coding‑агента (v2)

> Версия v2 — обновлена с учётом новых замечаний: **нельзя переводить по `Run`**, нужен **параграф/ячейка‑уровень**, **инлайн‑защита токенами**, и реалистичная стратегия **layout/reflow**.

---

## 1) Оценка нового ответа LLM (что реально полезно)

### Полезное и должно попасть в итоговую архитектуру
1. **Run fragmentation — критический стоп‑фактор.**  
   Word действительно дробит текст на `runs` произвольно (копипаст, автокоррекция, сохранения), поэтому перевод «по run’ам» ломает смысл и грамматику. Правильный уровень сегментации — **Paragraph / Table Cell**.

2. **Сохранение форматирования через инлайн‑теги/токены.**  
   Идея: собрать параграф в «плоскую строку» с маркерами форматирования (bold/italic/underline/…); переводить строку целиком; затем восстановить форматирование в DOCX по маркерам. Это один из немногих практичных способов сохранить форматирование **без перевода по run’ам**.

3. **Regex bypass должен быть инлайн, а не “skip whole cell”.**  
   Нельзя пропускать целые предложения/ячейки из‑за наличия part number — нужно **заменять чувствительные куски на плейсхолдеры** и переводить остальное.

4. **“len() → font shrink” — иллюзия.**  
   Ширина текста в Word зависит от гарнитуры/кернинга/ширины символов, поэтому простая пропорция по длине строки даст мусор. Нужна либо **Word COM измерялка**, либо принятие **reflow** (фикс ширины колонок + разрешить рост высоты строк).

### Что нужно поправить/уточнить (чтобы не закопаться в реализации)
- **HTML‑теги `<b>` как есть — хрупко.** Модель может «починить» HTML, переставить теги, поменять регистр. Лучше использовать **нестандартные маркеры**, которые модель *реже* правит: `⟦B_12⟧...⟦/B_12⟧`, `⟦I_7⟧...`, и т.п.  
- **Восстановление форматирования должно быть по “span map”, а не по “просто bold/italic”.** В CMM часто важны: ALL CAPS, подчеркивание, шрифт/размер, superscript/subscript, цвет (красный WARNING), выделение NOTE/CAUTION. Минимальный MVP: bold/italic/underline/sup/sub + сохранение исходных run properties по умолчанию.
- **Обновление ToC/LoEP чисто python‑docx’ом почти невозможно.** `python-docx` не пересчитывает поля Word (TOC, PAGEREF). Для честного обновления нужно:  
  - либо **Word COM** (Windows),  
  - либо оставлять поля как есть и требовать «Update Fields» пользователем в Word,  
  - либо сторонние инструменты (docx4j на Java), что усложняет.  
  В ТЗ это надо прописать как режимы.

---

## 2) Техническое задание (ТЗ)

### 2.1 Цель
Автоматизировать перевод больших техдоков авиатематики (CMM/AMM/IPC) в формате `.docx` (часто полученных конвертацией из PDF) на русский язык с:
- максимальным сохранением структуры/таблиц/стилей/маркировок WARNING‑CAUTION‑NOTE,
- защитой “непереводимых” сущностей (PN, размеры, моменты, ссылки, коды),
- отчётом QA для быстрой ручной вычитки.

### 2.2 Вход/выход
**Вход:**
- `source.docx`
- конфиг проекта `config.yaml` (язык, режимы, regex‑паттерны, терминобаза, LLM параметры)
- опционально: `termbase.csv` / `termbase.sqlite`

**Выход:**
- `target_ru.docx` (переведённый)
- `qa_report.html` (+ `qa.jsonl` журнал проверок)
- `translation_cache.sqlite` (TM/кэш; можно общий на проект)

### 2.3 Ограничения и допущения
- Целевая платформа: **Python 3.11+**.
- Библиотеки: `python-docx` + прямое OXML редактирование где нужно.
- LLM доступ через абстрактный адаптер (OpenAI/другие) — чтобы менять провайдера без переписывания пайплайна.
- Режимы layout:
  - **Mode A (Cross‑platform):** фиксируем ширины колонок, разрешаем рост высоты строк (reflow), поля TOC/LoEP не пересчитываем программно (только флаг “needs_update_fields”).
  - **Mode B (Windows COM):** дополнительно обновляем поля, и опционально “shrink‑to‑fit” точечно для таблиц/ячеек.

### 2.4 Функциональные требования (FR)
**FR1. Извлечение контента**
- Обойти все:
  - параграфы документа,
  - параграфы внутри таблиц (все ячейки),
  - заголовки/колонтитулы (если включено),
  - текст в текстбоксах/shape’ах — *опционально* (часто сложнее; можно как v3).
- Для каждой текстовой единицы создать объект `Segment`:
  - `segment_id` (устойчивый),
  - `location` (page неизвестен; но path: table[i]/row[j]/cell[k]/p[m] или body/p[n]),
  - `source_text_plain`,
  - `source_text_tagged`,
  - `style_spans` (карта форматирования),
  - `context` (заголовок секции, caption таблицы, header колонки).

**FR2. Tagging форматирования**
- Конвертировать исходный параграф (набор runs) в строку с маркерами:
  - минимум: bold, italic, underline, superscript, subscript
  - желательно: smallcaps/allcaps, color (только как метка), “warning/caution/note” признак.
- Формат маркеров: `⟦B_12⟧...⟦/B_12⟧` (где `12` — индекс span в параграфе).  
  Требование: маркеры **уникальны внутри сегмента**, не пересекаются, корректно вложены.

**FR3. Token Shield (инлайн‑плейсхолдеры)**
- До отправки в LLM заменить **внутри строки** все защищаемые сущности на плейсхолдеры вида `⟦PN_1⟧`, `⟦REF_2⟧`, `⟦DIM_3⟧`, `⟦ATA_4⟧`, `⟦FIG_5⟧`, `⟦STEP_6⟧`, `⟦UNIT_7⟧` и т.п.
- Вести `token_map` (placeholder → original).
- После перевода выполнить детокенизацию и строгую валидацию неизменности плейсхолдеров.

**FR4. Терминобаза и кэш**
- SQLite:
  - `tm_exact(source_hash, source_norm, target_ru, meta)`
  - `termbase(term_en, term_ru, domain, notes, priority)`
- Перед вызовом LLM:
  1) попытка exact‑match по нормализованной строке (без токенов, сжатые пробелы),
  2) если найдено — использовать.
- Иначе — LLM.

**FR5. Перевод через LLM**
- Стабильная системная инструкция:
  - не менять плейсхолдеры `⟦...⟧`,
  - сохранять маркеры форматирования `⟦B_..⟧` и т.п.,
  - переводить техническим русским стилем, без “креатива”.
- Передавать контекст: заголовок раздела, заголовок колонки таблицы, тип блока (NOTE/CAUTION/WARNING).

**FR6. Восстановление DOCX**
- На уровне параграфа:
  - очистить существующие runs,
  - создать новые runs по распарсенным `style_spans` после перевода,
  - сохранить свойства параграфа (style, numbering, alignment) как было.
- Для таблиц:
  - не менять структуру таблиц (кол-во строк/колонок).
  - **Mode A:** фиксировать ширины колонок через OXML (`w:tblGrid`, `w:tcW`) при необходимости.

**FR7. QA и отчёт**
- Генерировать `qa_report.html` с таблицей проблем:
  - token mismatch (потерян/изменён плейсхолдер),
  - числовые несоответствия (сравнение извлечённых чисел/единиц),
  - WARNING/CAUTION/NOTE потеряли выделение/капс,
  - подозрительная длина (например RU в 3× длиннее EN),
  - пустой перевод / почти пустой.
- Для каждого issue: `segment_id`, location, source, target, diff, рекомендации.

### 2.5 Нефункциональные требования (NFR)
- **Надёжность:** пайплайн возобновляемый (resume) — хранить прогресс по `segment_id` в SQLite/JSONL.
- **Производительность:** батчинг + параллелизм с ограничением RPS.
- **Трассируемость:** логирование (structured), сохранение промптов/ответов (опционально, с редактированием PII).
- **Тестируемость:** unit‑tests на токенизацию/детокенизацию/парсер тегов; интеграционный тест на маленьком `.docx`.

### 2.6 Критерии приёмки
- 100% сохранение плейсхолдеров `⟦...⟧` (строгое равенство).
- Не разрушена структура документа (docx открывается; таблицы на месте).
- Форматирование bold/italic/underline/sup/sub сохранено **по span map** (минимум).
- QA отчёт создаётся и корректно указывает сегменты с ошибками.
- Для Mode B: поля ToC обновляются (если включено) без ручного открытия Word.

---

## 3) Архитектура (логическая и модульная)

### 3.1 Поток данных (pipeline)
1. **DOCX Reader**
   - обходит документ, строит список `Segment`
2. **Formatter Tagger**
   - runs → tagged string + `style_spans`
3. **Tokenizer (Shield)**
   - tagged string → shielded string + `token_map`
4. **Normalizer + TM lookup**
   - поиск в `tm_exact`
5. **LLM Translator**
   - shielded tagged string + context → translated shielded tagged string
6. **Validator**
   - проверка маркеров форматирования + плейсхолдеров + чисел/единиц
7. **Detokenizer**
   - восстановление исходных PN/размеров/ссылок
8. **DOCX Writer**
   - rebuild runs по style_spans
9. **Post‑processing**
   - Mode A: фиксация ширин, флаг update fields
   - Mode B: Word COM update fields + опциональный fit‑to‑cell
10. **QA Report**
   - HTML + JSONL

### 3.2 Модель данных (минимум)
```text
Segment:
  id: str
  location: str
  context: dict
  source_plain: str
  source_tagged: str
  style_spans: list[Span]        # start,end,style_flags
  shielded_text: str
  token_map: dict[str,str]
  target_shielded: str
  target_tagged: str
  target_plain: str
  qa: list[Issue]
```

### 3.3 Ключевые алгоритмы

#### A) Tagging runs → tagged string
- Пройти по runs в параграфе.
- Для каждого run определить `style_flags` (B/I/U/SUP/SUB).
- Слить соседние runs с одинаковыми flags в один span.
- Сгенерировать маркеры: `⟦B_1⟧...⟦/B_1⟧` и т.п.  
  *Важно:* индекс должен ссылаться на span, чтобы потом восстановить.

#### B) Token Shield (Regex)
Рекомендованный порядок (от более специфичных к менее):
1) диапазоны ссылок вида `(17-20)`, `Fig. 2`, `Ref. (a)`  
2) ATA главы `\d{2}-\d{2}-\d{2}`
3) part numbers / stock numbers:
   - длинные цифры `\d{6,}`
   - буквенно‑цифровые `[A-Z0-9]{4,}[-/][A-Z0-9-]{2,}` (конфигурируемо)
4) размеры/единицы: `45 ± 5 N·m`, `0.25 in`, `3.2 mm`
5) даты/серийники (по проекту)

Требование: токенизация **не должна ломать маркеры форматирования**.  
То есть сначала tagging, потом token shield, но regex должен игнорировать `⟦...⟧`.

#### C) Валидация
- Проверить, что множество плейсхолдеров до и после совпадает.
- Проверить, что формат‑маркеры корректно вложены и совпали по списку.
- Проверить числа:
  - извлечь все числа/±/десятичные/диапазоны до и после (без плейсхолдеров),
  - несовпадения → issue.

---

## 4) Стратегия layout (реалистично)

### Mode A: Cross‑platform (рекомендуемый MVP)
- **Не пытаемся** подгонять высоту/шрифт по метрикам.
- Фиксируем ширины колонок (если таблицы «прыгают» после правок):
  - через `w:tblLayout w:type="fixed"`,
  - `w:tblGrid` + `w:tcW` где нужно.
- Разрешаем Word делать переносы и рост высоты строк.
- В конце помечаем документ как требующий обновления полей (в отчёте).

### Mode B: Windows + Word COM (опционально, “enterprise mode”)
- Открыть Word невидимо, обновить поля (TOC/LoEP), пересчитать страницы.
- Опционально: для выбранных таблиц/ячеек пробовать “shrink to fit” или уменьшение шрифта до минимума (floor 8 pt), пока не влезет.
- Это медленно, но даёт “печатную” стабильность.

---

## 5) Пакетирование и структура репозитория
```text
docx_ru_translate/
  pyproject.toml
  README.md
  config/
    config.example.yaml
    regex_presets.yaml
  src/
    docxru/
      __init__.py
      cli.py
      pipeline.py
      docx_reader.py
      docx_writer.py
      tagging.py
      token_shield.py
      validator.py
      tm.py
      llm.py
      qa_report.py
      oxml_table_fix.py
      com_word.py         # optional
  tests/
    test_tagging_roundtrip.py
    test_token_shield.py
    test_validator.py
  samples/
    mini.docx
```

---

## 6) Серия промптов для coding‑агента (Cursor/Devin/Copilot Chat)

> Ниже — последовательность промптов. Каждый можно копировать как есть. Они спроектированы так, чтобы агент генерировал **код, тесты, CLI и документацию**, а не «кусочки».

### Prompt 1 — Design Doc + интерфейсы
**Задача:** спроектируй проект `docx_ru_translate` по ТЗ ниже и выдай design doc.

**Контекст/ТЗ (вклей целиком):**
- Цель: перевод DOCX CMM/AMM → RU с сохранением форматирования и защитой плейсхолдеров.
- Нельзя переводить по `Run` (Word дробит runs произвольно). Перевод только на уровне Paragraph/Cell.
- Форматирование сохраняем через span‑tagging: `⟦B_12⟧...⟦/B_12⟧`, `⟦I_..⟧`, `⟦U_..⟧`, `⟦SUP_..⟧`, `⟦SUB_..⟧`.
- Token Shield: PN/ATA/units/refs заменяем на `⟦PN_1⟧` и т.п. строго инлайн.
- После перевода: строгая валидация плейсхолдеров и маркеров; детокенизация; восстановление runs.
- Mode A: cross‑platform, reflow OK, поля TOC не обновляем.
- Mode B: опционально Word COM обновляет поля/ToC.
- Нужны: CLI, SQLite TM, HTML QA report, unit tests.

**Требования к ответу:**
1) Архитектура модулей (файлы/классы/функции).
2) Data model `Segment` и схемы БД (SQL).
3) Поток пайплайна + точки логирования/возобновления.
4) План тестов (unit + integration).
5) Риски и mitigations (особенно теги/плейсхолдеры).

---

### Prompt 2 — Skeleton проекта + CLI
Сгенерируй рабочий репозиторий (структура папок) и минимальный runnable CLI.

**Требования:**
- `python -m docxru translate --input source.docx --output target.docx --config config.yaml`
- Логи в stdout + файл `run.log`
- Заглушки модулей, но CLI должен запускаться и создавать выходной docx‑копию без перевода.
- Добавь `pyproject.toml` (poetry/uv/pip-tools — выбери одно) и инструкции в README.
- Добавь GitHub‑friendly структуру и `pre-commit` (black/ruff/mypy по минимуму).
- Никаких “…” в коде. Всё должно импортироваться.

---

### Prompt 3 — Реализация Tagging (runs → tagged string) + roundtrip tests
Реализуй модуль `tagging.py`:

**API:**
- `paragraph_to_tagged(paragraph) -> (tagged_text: str, spans: list[Span])`
- `tagged_to_runs(paragraph, tagged_text: str, spans_schema_version: int = 1) -> None`
- `Span` включает: `span_id`, `start`, `end`, `flags` (B/I/U/SUP/SUB), и опционально `run_style_snapshot`.

**Условия:**
- Tagging должен сливать соседние runs с одинаковыми flags.
- Маркеры должны быть *уникальны* и *корректно вложены*.
- Roundtrip test: взять mini.docx с разным форматированием, преобразовать в tagged, затем обратно в runs, сравнить визуально‑логически:
  - текст совпадает,
  - флаги форматирования на соответствующих подстроках совпадают (проверка по runs).
- Добавь property‑based тест на случайные комбинации spans (если уместно).

---

### Prompt 4 — Token Shield (regex) + безопасное взаимодействие с тегами
Реализуй `token_shield.py`:

**API:**
- `shield(text: str, patterns: PatternSet) -> (shielded: str, token_map: dict[str,str])`
- `unshield(text: str, token_map: dict[str,str]) -> str`
- `extract_numbers(text: str) -> list[str]` (для QA)

**Ключевые требования:**
- Токенизатор не должен трогать маркеры `⟦...⟧` и их содержимое.
- Плейсхолдеры должны быть детерминированы (стабильная нумерация по порядку в тексте).
- Unit tests: смешанный текст типа  
  `Remove the ⟦B_1⟧bolt⟦/B_1⟧ (1-40) and washer PN 201587001, torque 45 ± 5 N·m.`  
  После shield/unshield текст должен совпасть байт‑в‑байт.

---

### Prompt 5 — LLM адаптер + промпт перевода
Реализуй `llm.py` как абстракцию провайдера:

**API:**
- `class LLMClient: translate(text: str, context: dict) -> str`
- Реализация `MockLLMClient` (для тестов) + пример `OpenAIClient` (без реального ключа; считай env var).

**Системная инструкция (в коде как template):**
- Не изменяй и не переводить плейсхолдеры вида `⟦PN_1⟧`, `⟦DIM_2⟧`, а также маркеры форматирования `⟦B_3⟧...⟦/B_3⟧` — оставить **строго** как есть.
- Переводить техническим русским: кратко, повелительное наклонение для процедур, без “воды”.
- Сохранять пунктуацию/нумерацию/скобки.
- Не добавлять новых предупреждений/предположений.

Добавь unit test: MockLLMClient возвращает предсказуемый результат; пайплайн проходит.

---

### Prompt 6 — Pipeline + resume + SQLite TM
Собери `pipeline.py`:

**Требования:**
- Итерация по `Segment` из reader.
- На каждый сегмент:
  1) tagging,
  2) shield,
  3) TM exact lookup,
  4) если нет — LLM translate,
  5) validate,
  6) unshield,
  7) write runs.
- Resume: таблица `progress(segment_id, status, updated_at, error)` + возможность `--resume`.
- Batch/concurrency: параллельный перевод, но запись в docx последовательно (или через очередь).
- Логи: сколько сегментов, сколько из TM, сколько из LLM, ошибки.

---

### Prompt 7 — Validator + QA report HTML
Реализуй `validator.py` и `qa_report.py`:

**Проверки:**
- placeholders: множества совпали 1:1
- format tags: список/структура маркеров совпали
- numbers: `extract_numbers(source_unshielded)` == `extract_numbers(target_unshielded)` (как минимум множество/последовательность; опиши политику)
- WARNING/CAUTION/NOTE: если в source есть эти слова в капсе, сохранить капс/выделение (минимум bold).

**Отчёт:**
- HTML таблица с фильтрами по типу issue.
- Для каждого issue: location, source, target, подсветка отличий (diff‑match‑patch или простая подсветка).

---

### Prompt 8 — OXML фиксация таблиц + (опционально) Word COM режим
Реализуй:
- `oxml_table_fix.py`: утилиты для `w:tblLayout type="fixed"`, `w:tblGrid`, `w:tcW`.
- `com_word.py` (optional, Windows only):
  - открыть docx, `Fields.Update()`, сохранить,
  - опционально пройти таблицы и применить shrink‑to‑fit/уменьшение шрифта до floor.

Сделай так, чтобы проект работал без COM (Mode A), а COM включался флагом `--mode com`.

---

## 7) Рекомендованный “боевой” prompt для переводящей модели (если ты управляешь LLM сам)
> Это не prompt для coding‑агента, а шаблон **для самой модели перевода** внутри `llm.py`.

**System / Instruction:**
- Ты переводишь авиационную техдокументацию (CMM/AMM).  
- Переведи на русский техническим стилем.  
- **НЕЛЬЗЯ** менять строки‑маркеры вида `⟦...⟧` и парные маркеры `⟦B_1⟧...⟦/B_1⟧`, `⟦I_..⟧`, `⟦U_..⟧`, `⟦SUP_..⟧`, `⟦SUB_..⟧`. Оставь их в точности.  
- Числа, знаки ±, диапазоны, единицы измерения — оставить как в исходном.  
- Не добавляй ничего от себя.

**User payload:**
- Context: {section_header, table_header, block_type}  
- Text: `<shielded_tagged_text>`

---

## 8) Риски и “failure modes” (чтобы заложить в код)
- Модель может:
  - потерять/переставить маркеры → лечится строгой валидацией + повторным запросом (“fix tags only”).
  - изменить пробелы вокруг плейсхолдеров → детокенизация должна быть tolerant к `⟦PN_1⟧,` и т.п.
- DOCX после правок может сломаться из‑за некорректного OXML → покрыть интеграционным тестом (открытие Word не автоматизируем, но проверяем что zip/parts валидны).
- Списки/нумерация: python-docx иногда “капризный” → не менять paragraph.style и numbering properties.
- Текст в фигурах/текстбоксах может остаться непереведённым → явно задокументировать как “не в MVP”.

---

## Next steps
- [ ] Скопируй этот файл в репозиторий как `SPEC_v2.md`
- [ ] Прогони prompts 1→8 на своём coding‑агенте, фиксируя результаты в PR’ах
- [ ] Сразу добавь `samples/mini.docx` с таблицами/NOTE/CAUTION и прогоняй интеграционный тест на каждом шаге
- [ ] Определи, нужен ли тебе Mode B (Word COM) или достаточно Mode A для первой версии

ИМХО: ключевой апгрейд — **параграф‑уровень + span‑tagging + инлайн‑плейсхолдеры + строгий QA**, а layout лучше сначала решать через **reflow**, а не “магией” подбора шрифта.
